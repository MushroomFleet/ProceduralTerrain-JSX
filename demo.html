<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Procedural Terrain Generator | SVGA Wireframe Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body, #root {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0a0a;
    }
    
    /* Custom scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }
    ::-webkit-scrollbar-track {
      background: #111;
    }
    ::-webkit-scrollbar-thumb {
      background: #0f0;
      border-radius: 3px;
    }
    
    /* Loading screen */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      font-family: "Courier New", monospace;
      color: #0f0;
    }
    
    #loading .spinner {
      width: 40px;
      height: 40px;
      border: 2px solid #111;
      border-top-color: #0f0;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    #loading .text {
      letter-spacing: 4px;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="spinner"></div>
    <div class="text">INITIALIZING TERRAIN ENGINE</div>
  </div>
  <div id="root"></div>

  <!-- Dependencies -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    // ═══════════════════════════════════════════════════════════════════════════════
    // SEEDED PRNG - Mulberry32 algorithm for deterministic randomness
    // ═══════════════════════════════════════════════════════════════════════════════
    class SeededRNG {
      constructor(seed) {
        this.seed = this.hashString(seed);
        this.state = this.seed;
      }

      hashString(str) {
        if (typeof str === 'number') return str >>> 0;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return Math.abs(hash) || 1;
      }

      next() {
        let t = this.state += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }

      range(min, max) {
        return min + this.next() * (max - min);
      }

      reset() {
        this.state = this.seed;
      }
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // SIMPLEX NOISE - Seeded implementation for coherent terrain
    // ═══════════════════════════════════════════════════════════════════════════════
    class SeededNoise {
      constructor(rng) {
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        
        const p = new Uint8Array(256);
        for (let i = 0; i < 256; i++) p[i] = i;
        
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(rng.next() * (i + 1));
          [p[i], p[j]] = [p[j], p[i]];
        }
        
        for (let i = 0; i < 512; i++) {
          this.perm[i] = p[i & 255];
          this.permMod12[i] = this.perm[i] % 12;
        }
        
        this.grad3 = [
          [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
          [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
          [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
        ];
        
        this.F2 = 0.5 * (Math.sqrt(3) - 1);
        this.G2 = (3 - Math.sqrt(3)) / 6;
      }

      noise2D(xin, yin) {
        const { perm, permMod12, grad3, F2, G2 } = this;
        let n0, n1, n2;
        
        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;
        
        let i1, j1;
        if (x0 > y0) { i1 = 1; j1 = 0; }
        else { i1 = 0; j1 = 1; }
        
        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;
        
        const ii = i & 255;
        const jj = j & 255;
        const gi0 = permMod12[ii + perm[jj]];
        const gi1 = permMod12[ii + i1 + perm[jj + j1]];
        const gi2 = permMod12[ii + 1 + perm[jj + 1]];
        
        let t0 = 0.5 - x0*x0 - y0*y0;
        if (t0 < 0) n0 = 0;
        else {
          t0 *= t0;
          n0 = t0 * t0 * (grad3[gi0][0]*x0 + grad3[gi0][1]*y0);
        }
        
        let t1 = 0.5 - x1*x1 - y1*y1;
        if (t1 < 0) n1 = 0;
        else {
          t1 *= t1;
          n1 = t1 * t1 * (grad3[gi1][0]*x1 + grad3[gi1][1]*y1);
        }
        
        let t2 = 0.5 - x2*x2 - y2*y2;
        if (t2 < 0) n2 = 0;
        else {
          t2 *= t2;
          n2 = t2 * t2 * (grad3[gi2][0]*x2 + grad3[gi2][1]*y2);
        }
        
        return 70 * (n0 + n1 + n2);
      }

      fractalNoise(x, y, octaves = 4, lacunarity = 2, persistence = 0.5) {
        let total = 0;
        let frequency = 1;
        let amplitude = 1;
        let maxValue = 0;
        
        for (let i = 0; i < octaves; i++) {
          total += this.noise2D(x * frequency, y * frequency) * amplitude;
          maxValue += amplitude;
          amplitude *= persistence;
          frequency *= lacunarity;
        }
        
        return total / maxValue;
      }
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // BIOME CONFIGURATIONS - SVGA-style color palettes
    // ═══════════════════════════════════════════════════════════════════════════════
    const BIOMES = {
      grassland: {
        name: 'Grassland',
        heightScale: 8,
        noiseScale: 0.08,
        octaves: 4,
        colors: {
          deep:   { r: 0.10, g: 0.28, b: 0.16 },
          low:    { r: 0.18, g: 0.35, b: 0.15 },
          mid:    { r: 0.29, g: 0.49, b: 0.14 },
          high:   { r: 0.49, g: 0.70, b: 0.26 },
          peak:   { r: 0.65, g: 0.84, b: 0.29 },
        },
        wireColor: '#1b5e20',
        thresholds: { deep: -0.3, low: 0, mid: 0.3, high: 0.6 }
      },
      
      desert: {
        name: 'Desert',
        heightScale: 6,
        noiseScale: 0.06,
        octaves: 3,
        colors: {
          deep:   { r: 0.55, g: 0.27, b: 0.07 },
          low:    { r: 0.76, g: 0.60, b: 0.42 },
          mid:    { r: 0.83, g: 0.65, b: 0.46 },
          high:   { r: 0.90, g: 0.79, b: 0.60 },
          peak:   { r: 0.98, g: 0.90, b: 0.76 },
        },
        wireColor: '#8b5a2b',
        thresholds: { deep: -0.4, low: -0.1, mid: 0.2, high: 0.5 }
      },
      
      tundra: {
        name: 'Tundra',
        heightScale: 5,
        noiseScale: 0.05,
        octaves: 5,
        colors: {
          deep:   { r: 0.18, g: 0.31, b: 0.31 },
          low:    { r: 0.38, g: 0.49, b: 0.55 },
          mid:    { r: 0.56, g: 0.64, b: 0.68 },
          high:   { r: 0.69, g: 0.75, b: 0.77 },
          peak:   { r: 0.93, g: 0.94, b: 0.95 },
        },
        wireColor: '#455a64',
        thresholds: { deep: -0.35, low: -0.05, mid: 0.25, high: 0.55 }
      },
      
      volcanic: {
        name: 'Volcanic',
        heightScale: 12,
        noiseScale: 0.07,
        octaves: 4,
        colors: {
          deep:   { r: 0.10, g: 0.10, b: 0.10 },
          low:    { r: 0.24, g: 0.16, b: 0.09 },
          mid:    { r: 0.36, g: 0.25, b: 0.22 },
          high:   { r: 0.75, g: 0.21, b: 0.05 },
          peak:   { r: 1.00, g: 0.34, b: 0.13 },
        },
        wireColor: '#ff3d00',
        thresholds: { deep: -0.4, low: -0.1, mid: 0.3, high: 0.7 }
      },
      
      ocean: {
        name: 'Ocean Floor',
        heightScale: 15,
        noiseScale: 0.04,
        octaves: 5,
        colors: {
          deep:   { r: 0.05, g: 0.11, b: 0.16 },
          low:    { r: 0.11, g: 0.23, b: 0.29 },
          mid:    { r: 0.18, g: 0.38, b: 0.44 },
          high:   { r: 0.29, g: 0.56, b: 0.66 },
          peak:   { r: 0.49, g: 0.78, b: 0.89 },
        },
        wireColor: '#0077b6',
        thresholds: { deep: -0.5, low: -0.2, mid: 0.1, high: 0.4 }
      },
      
      alien: {
        name: 'Alien World',
        heightScale: 10,
        noiseScale: 0.09,
        octaves: 4,
        colors: {
          deep:   { r: 0.10, g: 0.00, b: 0.20 },
          low:    { r: 0.29, g: 0.00, b: 0.50 },
          mid:    { r: 0.48, g: 0.12, b: 0.64 },
          high:   { r: 0.00, g: 0.90, b: 0.46 },
          peak:   { r: 0.46, g: 1.00, b: 0.01 },
        },
        wireColor: '#00c853',
        thresholds: { deep: -0.35, low: 0, mid: 0.35, high: 0.65 }
      },
      
      canyon: {
        name: 'Canyon',
        heightScale: 18,
        noiseScale: 0.05,
        octaves: 6,
        colors: {
          deep:   { r: 0.24, g: 0.15, b: 0.14 },
          low:    { r: 0.43, g: 0.30, b: 0.25 },
          mid:    { r: 0.63, g: 0.53, b: 0.50 },
          high:   { r: 0.84, g: 0.80, b: 0.78 },
          peak:   { r: 1.00, g: 0.54, b: 0.40 },
        },
        wireColor: '#795548',
        thresholds: { deep: -0.4, low: -0.15, mid: 0.2, high: 0.55 }
      },
      
      marsh: {
        name: 'Marshland',
        heightScale: 3,
        noiseScale: 0.1,
        octaves: 5,
        colors: {
          deep:   { r: 0.11, g: 0.19, b: 0.13 },
          low:    { r: 0.18, g: 0.29, b: 0.23 },
          mid:    { r: 0.29, g: 0.40, b: 0.25 },
          high:   { r: 0.42, g: 0.56, b: 0.31 },
          peak:   { r: 0.55, g: 0.76, b: 0.29 },
        },
        wireColor: '#33691e',
        thresholds: { deep: -0.25, low: 0.05, mid: 0.25, high: 0.5 }
      }
    };

    const BIOME_TYPES = Object.keys(BIOMES);

    // ═══════════════════════════════════════════════════════════════════════════════
    // HEIGHT-TO-COLOR INTERPOLATION
    // ═══════════════════════════════════════════════════════════════════════════════
    function lerpColor(c1, c2, t) {
      return {
        r: c1.r + (c2.r - c1.r) * t,
        g: c1.g + (c2.g - c1.g) * t,
        b: c1.b + (c2.b - c1.b) * t
      };
    }

    function getVertexColor(height, biome) {
      const { colors, thresholds } = biome;
      const h = height;
      
      if (h < thresholds.deep) {
        return { ...colors.deep };
      } else if (h < thresholds.low) {
        const t = (h - thresholds.deep) / (thresholds.low - thresholds.deep);
        return lerpColor(colors.deep, colors.low, t);
      } else if (h < thresholds.mid) {
        const t = (h - thresholds.low) / (thresholds.mid - thresholds.low);
        return lerpColor(colors.low, colors.mid, t);
      } else if (h < thresholds.high) {
        const t = (h - thresholds.mid) / (thresholds.high - thresholds.mid);
        return lerpColor(colors.mid, colors.high, t);
      } else {
        const t = Math.min((h - thresholds.high) / (1 - thresholds.high), 1);
        return lerpColor(colors.high, colors.peak, t);
      }
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // MINIMAP CANVAS COMPONENT
    // ═══════════════════════════════════════════════════════════════════════════════
    function Minimap({ seed, biome, size = 100 }) {
      const canvasRef = useRef(null);
      
      useEffect(() => {
        if (!canvasRef.current) return;
        
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        canvas.width = size;
        canvas.height = size;
        
        const rng = new SeededRNG(seed);
        const noise = new SeededNoise(rng);
        const imageData = ctx.createImageData(size, size);
        
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const nx = (x / size - 0.5) * 2 * biome.noiseScale * 50;
            const ny = (y / size - 0.5) * 2 * biome.noiseScale * 50;
            
            let height = noise.fractalNoise(nx, ny, biome.octaves, 2.0, 0.5);
            height = Math.max(-1, Math.min(1, height));
            
            const color = getVertexColor(height, biome);
            const idx = (y * size + x) * 4;
            imageData.data[idx] = Math.floor(color.r * 255);
            imageData.data[idx + 1] = Math.floor(color.g * 255);
            imageData.data[idx + 2] = Math.floor(color.b * 255);
            imageData.data[idx + 3] = 255;
          }
        }
        
        ctx.putImageData(imageData, 0, 0);
        
        // Scanline effect
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        for (let i = 0; i < size; i += 2) {
          ctx.fillRect(0, i, size, 1);
        }
        
        // Border
        ctx.strokeStyle = biome.wireColor;
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, size, size);
        
      }, [seed, biome, size]);
      
      return <canvas ref={canvasRef} style={{ imageRendering: 'pixelated' }} />;
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // MAIN THREE.JS TERRAIN COMPONENT
    // ═══════════════════════════════════════════════════════════════════════════════
    function ThreeTerrain({ seed, biome, resolution, showWireframe, showSolid }) {
      const containerRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      const frameRef = useRef(null);
      const meshesRef = useRef({ solid: null, wire: null });
      
      // Mouse controls
      const mouseRef = useRef({ 
        isDown: false, 
        lastX: 0, 
        lastY: 0,
        rotationX: 0.6,
        rotationY: 0.4,
        distance: 60
      });

      // Generate terrain geometry
      const generateTerrain = useMemo(() => {
        const biomeConfig = BIOMES[biome] || BIOMES.grassland;
        const rng = new SeededRNG(seed);
        const noise = new SeededNoise(rng);
        const size = 50;
        
        const geometry = new THREE.PlaneGeometry(size, size, resolution, resolution);
        geometry.rotateX(-Math.PI / 2);
        
        const positions = geometry.attributes.position.array;
        const colors = new Float32Array(positions.length);
        const vertexCount = (resolution + 1) * (resolution + 1);
        
        for (let i = 0; i < vertexCount; i++) {
          const x = positions[i * 3];
          const z = positions[i * 3 + 2];
          
          const nx = x * biomeConfig.noiseScale;
          const nz = z * biomeConfig.noiseScale;
          
          let height = noise.fractalNoise(nx, nz, biomeConfig.octaves, 2.0, 0.5);
          const detail = noise.noise2D(nx * 3, nz * 3) * 0.15;
          height = Math.max(-1, Math.min(1, height + detail));
          
          positions[i * 3 + 1] = height * biomeConfig.heightScale;
          
          const color = getVertexColor(height, biomeConfig);
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
        }
        
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.computeVertexNormals();
        
        return { geometry, biomeConfig };
      }, [seed, biome, resolution]);

      // Initialize Three.js scene
      useEffect(() => {
        if (!containerRef.current) return;
        
        const container = containerRef.current;
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        scene.fog = new THREE.Fog(0x0a0a0a, 50, 120);
        sceneRef.current = scene;
        
        // Camera
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        cameraRef.current = camera;
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);
        rendererRef.current = renderer;
        
        // Lights
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);
        
        const directional = new THREE.DirectionalLight(0xffffff, 0.4);
        directional.position.set(50, 50, 25);
        scene.add(directional);
        
        // Grid
        const gridHelper = new THREE.GridHelper(100, 50, 0x222222, 0x1a1a1a);
        gridHelper.position.y = -0.5;
        scene.add(gridHelper);
        
        // Animation loop
        const animate = () => {
          frameRef.current = requestAnimationFrame(animate);
          
          const m = mouseRef.current;
          camera.position.x = Math.sin(m.rotationY) * Math.cos(m.rotationX) * m.distance;
          camera.position.y = Math.sin(m.rotationX) * m.distance;
          camera.position.z = Math.cos(m.rotationY) * Math.cos(m.rotationX) * m.distance;
          camera.lookAt(0, 0, 0);
          
          renderer.render(scene, camera);
        };
        animate();
        
        // Handle resize
        const handleResize = () => {
          const w = container.clientWidth;
          const h = container.clientHeight;
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
          renderer.setSize(w, h);
        };
        window.addEventListener('resize', handleResize);
        
        // Mouse controls
        const onMouseDown = (e) => {
          mouseRef.current.isDown = true;
          mouseRef.current.lastX = e.clientX;
          mouseRef.current.lastY = e.clientY;
        };
        
        const onMouseUp = () => {
          mouseRef.current.isDown = false;
        };
        
        const onMouseMove = (e) => {
          if (!mouseRef.current.isDown) return;
          const dx = e.clientX - mouseRef.current.lastX;
          const dy = e.clientY - mouseRef.current.lastY;
          mouseRef.current.rotationY += dx * 0.005;
          mouseRef.current.rotationX += dy * 0.005;
          mouseRef.current.rotationX = Math.max(0.1, Math.min(1.5, mouseRef.current.rotationX));
          mouseRef.current.lastX = e.clientX;
          mouseRef.current.lastY = e.clientY;
        };
        
        const onWheel = (e) => {
          e.preventDefault();
          mouseRef.current.distance += e.deltaY * 0.05;
          mouseRef.current.distance = Math.max(20, Math.min(120, mouseRef.current.distance));
        };
        
        // Touch controls
        const onTouchStart = (e) => {
          if (e.touches.length === 1) {
            mouseRef.current.isDown = true;
            mouseRef.current.lastX = e.touches[0].clientX;
            mouseRef.current.lastY = e.touches[0].clientY;
          }
        };
        
        const onTouchEnd = () => {
          mouseRef.current.isDown = false;
        };
        
        const onTouchMove = (e) => {
          if (!mouseRef.current.isDown || e.touches.length !== 1) return;
          const dx = e.touches[0].clientX - mouseRef.current.lastX;
          const dy = e.touches[0].clientY - mouseRef.current.lastY;
          mouseRef.current.rotationY += dx * 0.005;
          mouseRef.current.rotationX += dy * 0.005;
          mouseRef.current.rotationX = Math.max(0.1, Math.min(1.5, mouseRef.current.rotationX));
          mouseRef.current.lastX = e.touches[0].clientX;
          mouseRef.current.lastY = e.touches[0].clientY;
        };
        
        container.addEventListener('mousedown', onMouseDown);
        container.addEventListener('mouseup', onMouseUp);
        container.addEventListener('mouseleave', onMouseUp);
        container.addEventListener('mousemove', onMouseMove);
        container.addEventListener('wheel', onWheel, { passive: false });
        container.addEventListener('touchstart', onTouchStart);
        container.addEventListener('touchend', onTouchEnd);
        container.addEventListener('touchmove', onTouchMove);
        
        // Hide loading screen
        const loadingEl = document.getElementById('loading');
        if (loadingEl) {
          loadingEl.style.opacity = '0';
          loadingEl.style.transition = 'opacity 0.5s';
          setTimeout(() => loadingEl.style.display = 'none', 500);
        }
        
        return () => {
          cancelAnimationFrame(frameRef.current);
          window.removeEventListener('resize', handleResize);
          container.removeEventListener('mousedown', onMouseDown);
          container.removeEventListener('mouseup', onMouseUp);
          container.removeEventListener('mouseleave', onMouseUp);
          container.removeEventListener('mousemove', onMouseMove);
          container.removeEventListener('wheel', onWheel);
          container.removeEventListener('touchstart', onTouchStart);
          container.removeEventListener('touchend', onTouchEnd);
          container.removeEventListener('touchmove', onTouchMove);
          renderer.dispose();
          if (container.contains(renderer.domElement)) {
            container.removeChild(renderer.domElement);
          }
        };
      }, []);

      // Update terrain meshes when geometry changes
      useEffect(() => {
        const scene = sceneRef.current;
        if (!scene) return;
        
        // Remove old meshes
        if (meshesRef.current.solid) {
          scene.remove(meshesRef.current.solid);
          meshesRef.current.solid.geometry.dispose();
          meshesRef.current.solid.material.dispose();
          meshesRef.current.solid = null;
        }
        if (meshesRef.current.wire) {
          scene.remove(meshesRef.current.wire);
          meshesRef.current.wire.geometry.dispose();
          meshesRef.current.wire.material.dispose();
          meshesRef.current.wire = null;
        }
        
        const { geometry, biomeConfig } = generateTerrain;
        
        // Solid mesh
        if (showSolid) {
          const solidMat = new THREE.MeshBasicMaterial({
            vertexColors: true,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.95
          });
          const solidMesh = new THREE.Mesh(geometry.clone(), solidMat);
          scene.add(solidMesh);
          meshesRef.current.solid = solidMesh;
        }
        
        // Wireframe mesh
        if (showWireframe) {
          const wireMat = new THREE.MeshBasicMaterial({
            color: biomeConfig.wireColor,
            wireframe: true,
            transparent: true,
            opacity: 0.6
          });
          const wireMesh = new THREE.Mesh(geometry.clone(), wireMat);
          wireMesh.position.y = 0.01;
          scene.add(wireMesh);
          meshesRef.current.wire = wireMesh;
        }
        
      }, [generateTerrain, showWireframe, showSolid]);

      return (
        <div 
          ref={containerRef} 
          style={{ 
            width: '100%', 
            height: '100%',
            cursor: 'grab'
          }} 
        />
      );
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // OVERLAY HUD
    // ═══════════════════════════════════════════════════════════════════════════════
    function TerrainHUD({ seed, biome, biomeConfig }) {
      return (
        <div style={{
          position: 'absolute',
          top: 16,
          right: 16,
          display: 'flex',
          flexDirection: 'column',
          gap: 10,
          fontFamily: '"Courier New", monospace',
          fontSize: 11,
          color: '#0f0',
          textShadow: '0 0 4px #0f0',
          pointerEvents: 'none',
        }}>
          {/* Minimap */}
          <div style={{
            background: 'rgba(0,0,0,0.85)',
            padding: 8,
            border: `1px solid ${biomeConfig.wireColor}`,
            boxShadow: `0 0 10px ${biomeConfig.wireColor}40`,
          }}>
            <div style={{ marginBottom: 6, letterSpacing: 2 }}>◈ TERRAIN MAP</div>
            <Minimap seed={seed} biome={biomeConfig} size={100} />
          </div>
          
          {/* Legend */}
          <div style={{
            background: 'rgba(0,0,0,0.85)',
            padding: 8,
            border: `1px solid ${biomeConfig.wireColor}`,
            boxShadow: `0 0 10px ${biomeConfig.wireColor}40`,
          }}>
            <div style={{ marginBottom: 6, letterSpacing: 2 }}>◈ ELEVATION</div>
            <div style={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
              {Object.entries(biomeConfig.colors).map(([key, color]) => (
                <div key={key} style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
                  <div style={{
                    width: 16,
                    height: 8,
                    background: `rgb(${Math.floor(color.r*255)},${Math.floor(color.g*255)},${Math.floor(color.b*255)})`,
                    border: '1px solid rgba(255,255,255,0.3)'
                  }} />
                  <span style={{ textTransform: 'uppercase' }}>{key}</span>
                </div>
              ))}
            </div>
          </div>
          
          {/* System Info */}
          <div style={{
            background: 'rgba(0,0,0,0.85)',
            padding: 8,
            border: `1px solid ${biomeConfig.wireColor}`,
            boxShadow: `0 0 10px ${biomeConfig.wireColor}40`,
          }}>
            <div style={{ marginBottom: 4, letterSpacing: 2 }}>◈ SYSTEM</div>
            <div>SEED: {String(seed).substring(0, 12)}</div>
            <div>BIOME: {biomeConfig.name.toUpperCase()}</div>
            <div>H.SCALE: {biomeConfig.heightScale}u</div>
          </div>
        </div>
      );
    }

    // ═══════════════════════════════════════════════════════════════════════════════
    // MAIN DEMO APPLICATION
    // ═══════════════════════════════════════════════════════════════════════════════
    function ProceduralTerrainDemo() {
      const [seed, setSeed] = useState('cosmic-landscape-42');
      const [biome, setBiome] = useState('grassland');
      const [resolution, setResolution] = useState(64);
      const [showWireframe, setShowWireframe] = useState(true);
      const [showSolid, setShowSolid] = useState(true);
      
      const biomeConfig = BIOMES[biome];
      
      const randomizeSeed = () => {
        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        let newSeed = '';
        for (let i = 0; i < 16; i++) {
          newSeed += chars[Math.floor(Math.random() * chars.length)];
        }
        setSeed(newSeed);
      };
      
      return (
        <div style={{ 
          width: '100vw', 
          height: '100vh', 
          background: '#0a0a0a',
          fontFamily: '"Courier New", monospace',
          overflow: 'hidden',
          position: 'relative'
        }}>
          {/* Control Panel */}
          <div style={{
            position: 'absolute',
            top: 16,
            left: 16,
            zIndex: 100,
            background: 'rgba(0,0,0,0.9)',
            border: '1px solid #333',
            padding: 16,
            display: 'flex',
            flexDirection: 'column',
            gap: 12,
            color: '#0f0',
            fontSize: 12,
            minWidth: 200,
            boxShadow: '0 0 20px rgba(0,255,0,0.1)',
          }}>
            <div style={{ 
              borderBottom: '1px solid #333', 
              paddingBottom: 8, 
              letterSpacing: 2,
              fontSize: 13 
            }}>
              ◈ TERRAIN CONTROL
            </div>
            
            {/* Seed */}
            <div>
              <label style={{ display: 'block', marginBottom: 4, opacity: 0.7 }}>SEED</label>
              <div style={{ display: 'flex', gap: 6 }}>
                <input
                  type="text"
                  value={seed}
                  onChange={(e) => setSeed(e.target.value)}
                  style={{
                    flex: 1,
                    background: '#111',
                    border: '1px solid #333',
                    color: '#0f0',
                    padding: '6px 8px',
                    fontFamily: 'inherit',
                    fontSize: 10,
                    width: 100,
                  }}
                />
                <button
                  onClick={randomizeSeed}
                  style={{
                    background: '#1a1a1a',
                    border: '1px solid #0f0',
                    color: '#0f0',
                    padding: '6px 10px',
                    cursor: 'pointer',
                    fontFamily: 'inherit',
                    fontSize: 10,
                  }}
                >
                  RND
                </button>
              </div>
            </div>
            
            {/* Biome */}
            <div>
              <label style={{ display: 'block', marginBottom: 4, opacity: 0.7 }}>BIOME</label>
              <select
                value={biome}
                onChange={(e) => setBiome(e.target.value)}
                style={{
                  width: '100%',
                  background: '#111',
                  border: '1px solid #333',
                  color: '#0f0',
                  padding: '6px 8px',
                  fontFamily: 'inherit',
                  cursor: 'pointer',
                  fontSize: 11,
                }}
              >
                {BIOME_TYPES.map(b => (
                  <option key={b} value={b}>{BIOMES[b].name.toUpperCase()}</option>
                ))}
              </select>
            </div>
            
            {/* Resolution */}
            <div>
              <label style={{ display: 'block', marginBottom: 4, opacity: 0.7 }}>
                RESOLUTION: {resolution}
              </label>
              <input
                type="range"
                min="16"
                max="96"
                step="8"
                value={resolution}
                onChange={(e) => setResolution(parseInt(e.target.value))}
                style={{ width: '100%', accentColor: '#0f0' }}
              />
            </div>
            
            {/* Toggles */}
            <div style={{ display: 'flex', gap: 16 }}>
              <label style={{ display: 'flex', alignItems: 'center', gap: 6, cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={showWireframe}
                  onChange={(e) => setShowWireframe(e.target.checked)}
                  style={{ accentColor: '#0f0' }}
                />
                WIRE
              </label>
              <label style={{ display: 'flex', alignItems: 'center', gap: 6, cursor: 'pointer' }}>
                <input
                  type="checkbox"
                  checked={showSolid}
                  onChange={(e) => setShowSolid(e.target.checked)}
                  style={{ accentColor: '#0f0' }}
                />
                SOLID
              </label>
            </div>
          </div>
          
          {/* Three.js Canvas */}
          <ThreeTerrain
            seed={seed}
            biome={biome}
            resolution={resolution}
            showWireframe={showWireframe}
            showSolid={showSolid}
          />
          
          {/* HUD Overlay */}
          <TerrainHUD seed={seed} biome={biome} biomeConfig={biomeConfig} />
          
          {/* Footer */}
          <div style={{
            position: 'absolute',
            bottom: 12,
            left: '50%',
            transform: 'translateX(-50%)',
            color: '#333',
            fontSize: 10,
            letterSpacing: 2,
            textAlign: 'center',
          }}>
            PROCEDURAL TERRAIN v1.0 • DRAG TO ROTATE • SCROLL TO ZOOM
          </div>
        </div>
      );
    }

    // Render the application
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ProceduralTerrainDemo />);
  </script>
</body>
</html>
